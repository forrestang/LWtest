<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LWtest - Lightweight Charts Demo</title>
    <script src="https://unpkg.com/lightweight-charts@5.0.8/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .left-menu {
            width: 250px;
            background-color: #2c3e50;
            color: white;
            padding: 20px 0;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        .menu-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid #34495e;
            margin-bottom: 20px;
        }

        .menu-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: background-color 0.3s;
            border-left: 3px solid transparent;
        }

        .menu-item:hover {
            background-color: #34495e;
            border-left-color: #3498db;
        }

        .menu-item.active {
            background-color: #3498db;
            border-left-color: #2980b9;
        }

        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .chart-title {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 18px;
            font-weight: bold;
        }

        .chart {
            width: 100%;
            height: 400px;
        }

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn:hover {
            background-color: #2980b9;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="left-menu" data-label="main-navigation">
            <div class="menu-header">
                <h2>LWtest Charts</h2>
            </div>
            <div class="menu-item active" data-label="candlestick-menu" onclick="showChart('candlestick')">
                ðŸ“ˆ Candlestick Chart
            </div>
            <div class="menu-item" data-label="line-menu" onclick="showChart('line')">
                ðŸ“Š Line Chart
            </div>
            <div class="menu-item" data-label="bar-menu" onclick="showChart('bar')">
                ðŸ“‹ Bar Chart
            </div>
            <div class="menu-item" data-label="area-menu" onclick="showChart('area')">
                ðŸŒ„ Area Chart
            </div>
            <div class="menu-item" data-label="websocket-toggle" onclick="toggleWebSocket()">
                ðŸ”Œ Connect WebSocket
            </div>
            <div style="padding: 15px 20px; border-top: 1px solid #34495e;">
                <div style="color: #bdc3c7; font-size: 14px; margin-bottom: 10px;">Symbols:</div>
                <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                    <input type="checkbox" id="btc-checkbox" data-label="btc-checkbox" checked onchange="toggleSymbol('BTC')" style="margin-right: 8px;">
                    <span style="color: #e74c3c;">ðŸ”´ BTC</span>
                </label>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="eth-checkbox" data-label="eth-checkbox" onchange="toggleSymbol('ETH')" style="margin-right: 8px;">
                    <span style="color: #00bcd4;">ðŸ”µ ETH</span>
                </label>
            </div>
        </nav>

        <main class="main-content">
            <div id="candlestick-chart" class="chart-container" data-label="candlestick-container">
                <div class="chart-title">Candlestick Chart</div>
                <div class="chart" data-label="candlestick-chart-area"></div>
                <div class="controls">
                    <button class="btn" data-label="candlestick-reset" onclick="resetChart('candlestick')">Reset Zoom</button>
                </div>
            </div>

            <div id="line-chart" class="chart-container" data-label="line-container" style="display: none;">
                <div class="chart-title">Line Chart</div>
                <div class="chart" data-label="line-chart-area"></div>
                <div class="controls">
                    <button class="btn" data-label="line-reset" onclick="resetChart('line')">Reset Zoom</button>
                </div>
            </div>

            <div id="bar-chart" class="chart-container" data-label="bar-container" style="display: none;">
                <div class="chart-title">Bar Chart</div>
                <div class="chart" data-label="bar-chart-area"></div>
                <div class="controls">
                    <button class="btn" data-label="bar-reset" onclick="resetChart('bar')">Reset Zoom</button>
                </div>
            </div>

            <div id="area-chart" class="chart-container" data-label="area-container" style="display: none;">
                <div class="chart-title">Area Chart</div>
                <div class="chart" data-label="area-chart-area"></div>
                <div class="controls">
                    <button class="btn" data-label="area-reset" onclick="resetChart('area')">Reset Zoom</button>
                </div>
            </div>
        </main>
    </div>

    <script>
        const { createChart, ColorType, CandlestickSeries, LineSeries, AreaSeries, BarSeries } = LightweightCharts;
        
        let charts = {};
        let chartSeries = {};
        let currentChart = 'candlestick';
        let ws = null;
        let isConnected = false;
        let candleHistory = {
            BTC: [],
            ETH: []
        };
        let historicalDataLoaded = {
            BTC: false,
            ETH: false
        };
        let activeSymbols = new Set(['BTC']); // Track which symbols are enabled


        // Initialize charts
        function initCharts() {
            // Candlestick Chart
            const candlestickContainer = document.querySelector('[data-label="candlestick-chart-area"]');
            
            // Ensure container is visible before getting dimensions
            const parentContainer = document.getElementById('candlestick-chart');
            parentContainer.style.display = 'block';
            
            charts.candlestick = createChart(candlestickContainer, {
                width: candlestickContainer.clientWidth,
                height: 400,
                layout: {
                    background: { type: ColorType.Solid, color: 'white' },
                    textColor: 'black',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                timeScale: {
                    borderColor: '#ccc',
                },
                rightPriceScale: {
                    borderColor: '#ccc',
                },
            });

            // Create series for both BTC and ETH
            chartSeries.BTC = charts.candlestick.addSeries(CandlestickSeries, {
                upColor: '#e74c3c',
                downColor: '#c0392b',
                borderVisible: false,
                wickUpColor: '#e74c3c',
                wickDownColor: '#c0392b',
            });
            
            chartSeries.ETH = charts.candlestick.addSeries(CandlestickSeries, {
                upColor: '#00bcd4',
                downColor: '#0097a7',
                borderVisible: false,
                wickUpColor: '#00bcd4',
                wickDownColor: '#0097a7',
            });
            
            console.log('BTC and ETH candlestick series created');

            // Line Chart
            const lineContainer = document.querySelector('[data-label="line-chart-area"]');
            charts.line = createChart(lineContainer, {
                width: lineContainer.clientWidth,
                height: 400,
                layout: {
                    background: { type: ColorType.Solid, color: 'white' },
                    textColor: 'black',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
            });

            // Create line series for both symbols
            chartSeries.BTCLine = charts.line.addSeries(LineSeries, {
                color: '#e74c3c',
                lineWidth: 2,
            });
            
            chartSeries.ETHLine = charts.line.addSeries(LineSeries, {
                color: '#00bcd4',
                lineWidth: 2,
            });

            // Bar Chart
            const barContainer = document.querySelector('[data-label="bar-chart-area"]');
            charts.bar = createChart(barContainer, {
                width: barContainer.clientWidth,
                height: 400,
                layout: {
                    background: { type: ColorType.Solid, color: 'white' },
                    textColor: 'black',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
            });

            // Create bar series for both symbols
            chartSeries.BTCBar = charts.bar.addSeries(BarSeries, {
                color: '#e74c3c',
                base: 0,
            });
            
            chartSeries.ETHBar = charts.bar.addSeries(BarSeries, {
                color: '#00bcd4',
                base: 0,
            });

            // Area Chart
            const areaContainer = document.querySelector('[data-label="area-chart-area"]');
            charts.area = createChart(areaContainer, {
                width: areaContainer.clientWidth,
                height: 400,
                layout: {
                    background: { type: ColorType.Solid, color: 'white' },
                    textColor: 'black',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
            });

            // Create area series for both symbols
            chartSeries.BTCArea = charts.area.addSeries(AreaSeries, {
                lineColor: '#e74c3c',
                topColor: 'rgba(231, 76, 60, 0.4)',
                bottomColor: 'rgba(231, 76, 60, 0.0)',
            });
            
            chartSeries.ETHArea = charts.area.addSeries(AreaSeries, {
                lineColor: '#00bcd4',
                topColor: 'rgba(0, 188, 212, 0.4)',
                bottomColor: 'rgba(0, 188, 212, 0.0)',
            });

            // Save current chart preference
            localStorage.setItem('LWtest_currentChart', currentChart);
        }
        
        // Toggle symbol visibility
        function toggleSymbol(symbol) {
            if (activeSymbols.has(symbol)) {
                activeSymbols.delete(symbol);
                console.log('Disabled', symbol);
                
                // Hide series for this symbol
                hideSymbolSeries(symbol);
                
                // Disconnect from WebSocket if connected and reconnect with updated symbols
                if (isConnected) {
                    disconnectWebSocket();
                    setTimeout(() => connectWebSocket(), 1000);
                }
            } else {
                activeSymbols.add(symbol);
                console.log('Enabled', symbol);
                
                // Show series for this symbol
                showSymbolSeries(symbol);
                
                // Reconnect WebSocket with new symbol if connected
                if (isConnected) {
                    disconnectWebSocket();
                    setTimeout(() => connectWebSocket(), 1000);
                }
            }
        }
        
        // Hide series for a symbol
        function hideSymbolSeries(symbol) {
            const seriesToHide = [
                chartSeries[symbol],
                chartSeries[symbol + 'Line'],
                chartSeries[symbol + 'Bar'],  
                chartSeries[symbol + 'Area']
            ];
            
            seriesToHide.forEach(series => {
                if (series) {
                    series.setData([]);
                }
            });
        }
        
        // Show series for a symbol (reload data)
        function showSymbolSeries(symbol) {
            if (candleHistory[symbol] && candleHistory[symbol].length > 0) {
                updateChartsForSymbol(symbol);
            }
        }


        // Fetch historical candle data from Hyperliquid API
        async function fetchHistoricalData() {
            const promises = [];
            
            // Fetch data for all active symbols
            for (const symbol of activeSymbols) {
                promises.push(fetchHistoricalDataForSymbol(symbol));
            }
            
            const results = await Promise.all(promises);
            return results.every(result => result === true);
        }
        
        // Fetch historical data for a specific symbol
        async function fetchHistoricalDataForSymbol(symbol) {
            try {
                console.log(`Fetching historical ${symbol} 5m candle data...`);
                
                const endTime = Date.now();
                // Get 250 candles * 5 minutes = 1250 minutes = ~21 hours of data
                const startTime = endTime - (250 * 5 * 60 * 1000);
                
                const response = await fetch('https://api.hyperliquid.xyz/info', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        type: "candleSnapshot",
                        req: {
                            coin: symbol,
                            interval: "5m",
                            startTime: startTime,
                            endTime: endTime
                        }
                    })
                });
                
                const data = await response.json();
                console.log(`${symbol} historical data received:`, data.length, 'candles');
                
                // Convert to Lightweight Charts format
                candleHistory[symbol] = data.map(candle => ({
                    time: Math.floor(candle.t / 1000), // Convert to seconds
                    open: parseFloat(candle.o),
                    high: parseFloat(candle.h),
                    low: parseFloat(candle.l),
                    close: parseFloat(candle.c)
                })).sort((a, b) => a.time - b.time);
                
                console.log(`Formatted ${symbol} historical data:`, candleHistory[symbol].length, 'candles');
                
                // Update charts with historical data for this symbol
                updateChartsForSymbol(symbol);
                historicalDataLoaded[symbol] = true;
                
                return true;
            } catch (error) {
                console.error(`Error fetching ${symbol} historical data:`, error);
                return false;
            }
        }
        
        // Update charts for a specific symbol
        function updateChartsForSymbol(symbol) {
            if (!candleHistory[symbol] || candleHistory[symbol].length === 0) return;
            
            console.log(`Updating charts for ${symbol}`);
            
            // Update candlestick chart
            if (chartSeries[symbol]) {
                chartSeries[symbol].setData(candleHistory[symbol]);
            }
            
            // Update other charts with close prices
            const lineData = candleHistory[symbol].map(candle => ({
                time: candle.time,
                value: candle.close
            }));
            
            if (chartSeries[symbol + 'Line']) {
                chartSeries[symbol + 'Line'].setData(lineData);
            }
            
            if (chartSeries[symbol + 'Area']) {
                chartSeries[symbol + 'Area'].setData(lineData);
            }
            
            if (chartSeries[symbol + 'Bar']) {
                chartSeries[symbol + 'Bar'].setData(lineData);
            }
            
            console.log(`Updated charts with ${symbol} data`);
        }

        // Connect to Hyperliquid WebSocket
        async function connectWebSocket() {
            if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
                return;
            }
            
            // First fetch historical data
            const historyLoaded = await fetchHistoricalData();
            if (!historyLoaded) {
                console.error('Failed to load historical data');
                return;
            }
            
            ws = new WebSocket('wss://api.hyperliquid.xyz/ws');
            
            ws.onopen = function() {
                console.log('WebSocket connected to Hyperliquid');
                isConnected = true;
                updateWebSocketButton();
                
                // Subscribe to candle data for all active symbols
                for (const symbol of activeSymbols) {
                    const subscription = {
                        method: "subscribe",
                        subscription: {
                            type: "candle",
                            coin: symbol,
                            interval: "5m"
                        }
                    };
                    
                    console.log(`Subscribing to ${symbol} candle data`);
                    ws.send(JSON.stringify(subscription));
                }
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('WebSocket message received:', data);
                
                // Handle candle data
                if (data.channel === "candle" && data.data) {
                    handleCandleData(data.data);
                } else if (data.data && Array.isArray(data.data)) {
                    // Handle if data is directly in data field
                    handleCandleData(data.data);
                } else if (Array.isArray(data)) {
                    // Handle if data is directly an array
                    handleCandleData(data);
                }
            };
            
            ws.onclose = function() {
                console.log('WebSocket connection closed');
                isConnected = false;
                updateWebSocketButton();
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                isConnected = false;
                updateWebSocketButton();
            };
        }

        // Disconnect WebSocket
        function disconnectWebSocket() {
            if (ws) {
                ws.close();
                ws = null;
                isConnected = false;
                updateWebSocketButton();
                console.log('WebSocket disconnected');
            }
        }

        // Toggle WebSocket connection
        function toggleWebSocket() {
            if (isConnected) {
                disconnectWebSocket();
            } else {
                connectWebSocket();
            }
        }

        // Update WebSocket button text
        function updateWebSocketButton() {
            const button = document.querySelector('[data-label="websocket-toggle"]');
            if (button) {
                if (isConnected) {
                    button.textContent = 'ðŸ”Œ Disconnect WebSocket';
                    button.classList.add('active');
                } else {
                    button.textContent = 'ðŸ”Œ Connect WebSocket';
                    button.classList.remove('active');
                }
            }
        }

        // Handle incoming candle data
        function handleCandleData(candleData) {
            console.log('Handling live candle data:', candleData);
            
            // Handle single candle object
            if (typeof candleData === 'object' && candleData.t && candleData.s) {
                const symbol = candleData.s; // Get symbol from candle data
                
                // Only process if this symbol is active
                if (!activeSymbols.has(symbol)) {
                    console.log(`Ignoring candle for inactive symbol: ${symbol}`);
                    return;
                }
                
                const formattedCandle = {
                    time: Math.floor(candleData.t / 1000), // Convert milliseconds to seconds
                    open: parseFloat(candleData.o),
                    high: parseFloat(candleData.h),
                    low: parseFloat(candleData.l),
                    close: parseFloat(candleData.c)
                };
                
                console.log(`Formatted live ${symbol} candle:`, formattedCandle);
                
                // Check for gaps between historical and live data
                if (historicalDataLoaded[symbol] && candleHistory[symbol] && candleHistory[symbol].length > 0) {
                    const lastHistoricalCandle = candleHistory[symbol][candleHistory[symbol].length - 1];
                    const timeDifference = formattedCandle.time - lastHistoricalCandle.time;
                    const expectedInterval = 5 * 60; // 5 minutes in seconds
                    
                    console.log(`${symbol} time difference between last historical and live:`, timeDifference, 'seconds');
                    
                    // If there's a gap, bridge it
                    if (timeDifference > expectedInterval) {
                        console.log(`Gap detected between historical and live data for ${symbol}`);
                        bridgeDataGap(symbol, lastHistoricalCandle, formattedCandle);
                    }
                    
                    // Check if this candle should update the last historical candle or add a new one
                    if (formattedCandle.time === lastHistoricalCandle.time) {
                        // Update existing candle
                        console.log(`Updating existing ${symbol} candle in history`);
                        candleHistory[symbol][candleHistory[symbol].length - 1] = formattedCandle;
                        updateChartsForSymbol(symbol);
                    } else {
                        // Add new candle to history
                        console.log(`Adding new ${symbol} candle to history`);
                        candleHistory[symbol].push(formattedCandle);
                        
                        // Keep only last 250 candles
                        if (candleHistory[symbol].length > 250) {
                            candleHistory[symbol] = candleHistory[symbol].slice(-250);
                        }
                        
                        updateChartsForSymbol(symbol);
                    }
                } else {
                    // No historical data, just update with live data
                    console.log(`No historical data for ${symbol}, updating with live candle only`);
                    if (chartSeries[symbol]) {
                        chartSeries[symbol].update(formattedCandle);
                    }
                    
                    const linePoint = {
                        time: formattedCandle.time,
                        value: formattedCandle.close
                    };
                    
                    if (chartSeries[symbol + 'Line']) {
                        chartSeries[symbol + 'Line'].update(linePoint);
                    }
                    
                    if (chartSeries[symbol + 'Area']) {
                        chartSeries[symbol + 'Area'].update(linePoint);
                    }
                    
                    if (chartSeries[symbol + 'Bar']) {
                        chartSeries[symbol + 'Bar'].update(linePoint);
                    }
                }
                
                return;
            }
            
            console.error('Unexpected candle data format:', typeof candleData, candleData);
        }
        
        // Bridge gap between historical and live data
        function bridgeDataGap(symbol, lastHistoricalCandle, firstLiveCandle) {
            console.log(`Bridging ${symbol} data gap from`, lastHistoricalCandle.time, 'to', firstLiveCandle.time);
            
            const interval = 5 * 60; // 5 minutes in seconds
            const gapCandles = [];
            
            let currentTime = lastHistoricalCandle.time + interval;
            
            while (currentTime < firstLiveCandle.time) {
                // Create bridge candle using last historical close price
                const bridgeCandle = {
                    time: currentTime,
                    open: lastHistoricalCandle.close,
                    high: lastHistoricalCandle.close,
                    low: lastHistoricalCandle.close,
                    close: lastHistoricalCandle.close
                };
                
                console.log(`Created ${symbol} bridge candle:`, bridgeCandle);
                gapCandles.push(bridgeCandle);
                currentTime += interval;
            }
            
            // Add bridge candles to history
            candleHistory[symbol] = candleHistory[symbol].concat(gapCandles);
            console.log(`Added ${gapCandles.length} bridge candles for ${symbol}`);
        }
        
        // Update all charts with current candle history
        function updateAllCharts() {
            if (candleHistory.length === 0) return;
            
            console.log('Updating charts with data:', candleHistory);
            console.log('Chart series available:', Object.keys(chartSeries));
            
            // Update candlestick chart
            if (chartSeries.candlestick) {
                console.log('Setting candlestick data:', candleHistory);
                chartSeries.candlestick.setData(candleHistory);
            } else {
                console.error('Candlestick series not found');
            }
            
            // Update line chart with close prices
            const lineData = candleHistory.map(candle => ({
                time: candle.time,
                value: candle.close
            }));
            
            if (chartSeries.line) {
                console.log('Setting line data:', lineData);
                chartSeries.line.setData(lineData);
            } else {
                console.error('Line series not found');
            }
            
            // Update area chart with close prices
            if (chartSeries.area) {
                console.log('Setting area data:', lineData);
                chartSeries.area.setData(lineData);
            } else {
                console.error('Area series not found');
            }
            
            // Update bar chart with close prices
            if (chartSeries.bar) {
                console.log('Setting bar data:', lineData);
                chartSeries.bar.setData(lineData);
            } else {
                console.error('Bar series not found');
            }
            
            console.log(`Updated charts with ${candleHistory.length} candles`);
            
            // Force chart resize to ensure visibility
            Object.values(charts).forEach(chart => {
                if (chart) {
                    chart.timeScale().fitContent();
                }
            });
        }

        // Show specific chart
        function showChart(chartType) {
            console.log('showChart called with:', chartType);
            
            // Hide all charts
            document.querySelectorAll('.chart-container').forEach(container => {
                console.log('Hiding container:', container.id);
                container.style.display = 'none';
            });
            
            // Remove active class from all menu items
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Show selected chart
            const targetChart = document.getElementById(chartType + '-chart');
            console.log('Showing chart container:', targetChart);
            targetChart.style.display = 'block';
            document.querySelector(`[data-label="${chartType}-menu"]`).classList.add('active');
            
            currentChart = chartType;
            localStorage.setItem('LWtest_currentChart', chartType);
            
            // Resize chart to fit container
            setTimeout(() => {
                console.log('Resizing chart:', chartType);
                if (charts[chartType]) {
                    console.log('Chart exists, calling resize');
                    charts[chartType].resize();
                    
                    // Check if data still exists after resize
                    console.log('Checking series after resize:', chartSeries[chartType]);
                    if (chartSeries[chartType]) {
                        console.log('Series still exists after resize');
                    } else {
                        console.error('Series lost after resize!');
                    }
                } else {
                    console.error('Chart not found for resize:', chartType);
                }
            }, 100);
        }

        // Reset chart zoom
        function resetChart(chartType) {
            if (charts[chartType]) {
                charts[chartType].timeScale().resetTimeScale();
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            Object.values(charts).forEach(chart => {
                chart.resize();
            });
        });

        // Load saved chart preference
        document.addEventListener('DOMContentLoaded', () => {
            currentChart = 'candlestick';
            
            console.log('DOM loaded, initializing charts');
            initCharts();
            console.log('Charts initialized, skipping showChart call');
            
            // Don't call showChart - leave the chart as initialized
        });
    </script>
</body>
</html>
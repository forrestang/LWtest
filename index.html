<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LWtest - Lightweight Charts Demo</title>
    <script src="https://unpkg.com/lightweight-charts@5.0.8/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .left-menu {
            width: 250px;
            background-color: #2c3e50;
            color: white;
            padding: 20px 0;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        .menu-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid #34495e;
            margin-bottom: 20px;
        }

        .menu-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: background-color 0.3s;
            border-left: 3px solid transparent;
        }

        .menu-item:hover {
            background-color: #34495e;
            border-left-color: #3498db;
        }

        .menu-item.active {
            background-color: #3498db;
            border-left-color: #2980b9;
        }

        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .chart-title {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 18px;
            font-weight: bold;
        }

        .chart {
            width: 100%;
            height: 400px;
        }

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn:hover {
            background-color: #2980b9;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="left-menu" data-label="main-navigation">
            <div class="menu-header">
                <h2>LWtest Charts</h2>
            </div>
            <div class="menu-item active" data-label="candlestick-menu" onclick="showChart('candlestick')">
                ðŸ“ˆ Candlestick Chart
            </div>
            <div class="menu-item" data-label="line-menu" onclick="showChart('line')">
                ðŸ“Š Line Chart
            </div>
            <div class="menu-item" data-label="bar-menu" onclick="showChart('bar')">
                ðŸ“‹ Bar Chart
            </div>
            <div class="menu-item" data-label="area-menu" onclick="showChart('area')">
                ðŸŒ„ Area Chart
            </div>
            <div class="menu-item" data-label="websocket-toggle" onclick="toggleWebSocket()">
                ðŸ”Œ Connect WebSocket
            </div>
        </nav>

        <main class="main-content">
            <div id="candlestick-chart" class="chart-container" data-label="candlestick-container">
                <div class="chart-title">Candlestick Chart</div>
                <div class="chart" data-label="candlestick-chart-area"></div>
                <div class="controls">
                    <button class="btn" data-label="candlestick-reset" onclick="resetChart('candlestick')">Reset Zoom</button>
                </div>
            </div>

            <div id="line-chart" class="chart-container" data-label="line-container" style="display: none;">
                <div class="chart-title">Line Chart</div>
                <div class="chart" data-label="line-chart-area"></div>
                <div class="controls">
                    <button class="btn" data-label="line-reset" onclick="resetChart('line')">Reset Zoom</button>
                </div>
            </div>

            <div id="bar-chart" class="chart-container" data-label="bar-container" style="display: none;">
                <div class="chart-title">Bar Chart</div>
                <div class="chart" data-label="bar-chart-area"></div>
                <div class="controls">
                    <button class="btn" data-label="bar-reset" onclick="resetChart('bar')">Reset Zoom</button>
                </div>
            </div>

            <div id="area-chart" class="chart-container" data-label="area-container" style="display: none;">
                <div class="chart-title">Area Chart</div>
                <div class="chart" data-label="area-chart-area"></div>
                <div class="controls">
                    <button class="btn" data-label="area-reset" onclick="resetChart('area')">Reset Zoom</button>
                </div>
            </div>
        </main>
    </div>

    <script>
        const { createChart, ColorType, CandlestickSeries, LineSeries, AreaSeries, BarSeries } = LightweightCharts;
        
        let charts = {};
        let chartSeries = {};
        let currentChart = 'candlestick';
        let ws = null;
        let isConnected = false;
        let candleHistory = [];
        let historicalDataLoaded = false;


        // Initialize charts
        function initCharts() {
            // Candlestick Chart
            const candlestickContainer = document.querySelector('[data-label="candlestick-chart-area"]');
            
            // Ensure container is visible before getting dimensions
            const parentContainer = document.getElementById('candlestick-chart');
            parentContainer.style.display = 'block';
            
            charts.candlestick = createChart(candlestickContainer, {
                width: candlestickContainer.clientWidth,
                height: 400,
                layout: {
                    background: { type: ColorType.Solid, color: 'white' },
                    textColor: 'black',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                timeScale: {
                    borderColor: '#ccc',
                },
                rightPriceScale: {
                    borderColor: '#ccc',
                },
            });

            chartSeries.candlestick = charts.candlestick.addSeries(CandlestickSeries, {
                upColor: '#4CAF50',
                downColor: '#F44336',
                borderVisible: false,
                wickUpColor: '#4CAF50',
                wickDownColor: '#F44336',
            });
            console.log('Candlestick series created:', chartSeries.candlestick);

            // Line Chart
            const lineContainer = document.querySelector('[data-label="line-chart-area"]');
            charts.line = createChart(lineContainer, {
                width: lineContainer.clientWidth,
                height: 400,
                layout: {
                    background: { type: ColorType.Solid, color: 'white' },
                    textColor: 'black',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
            });

            chartSeries.line = charts.line.addSeries(LineSeries, {
                color: '#2196F3',
                lineWidth: 2,
            });

            // Bar Chart
            const barContainer = document.querySelector('[data-label="bar-chart-area"]');
            charts.bar = createChart(barContainer, {
                width: barContainer.clientWidth,
                height: 400,
                layout: {
                    background: { type: ColorType.Solid, color: 'white' },
                    textColor: 'black',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
            });

            chartSeries.bar = charts.bar.addSeries(BarSeries, {
                color: '#FF9800',
                base: 0,
            });

            // Area Chart
            const areaContainer = document.querySelector('[data-label="area-chart-area"]');
            charts.area = createChart(areaContainer, {
                width: areaContainer.clientWidth,
                height: 400,
                layout: {
                    background: { type: ColorType.Solid, color: 'white' },
                    textColor: 'black',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
            });

            chartSeries.area = charts.area.addSeries(AreaSeries, {
                lineColor: '#9C27B0',
                topColor: 'rgba(156, 39, 176, 0.4)',
                bottomColor: 'rgba(156, 39, 176, 0.0)',
            });

            // Save current chart preference
            localStorage.setItem('LWtest_currentChart', currentChart);
        }


        // Fetch historical candle data from Hyperliquid API
        async function fetchHistoricalData() {
            try {
                console.log('Fetching historical BTC 5m candle data...');
                
                const endTime = Date.now();
                // Get 250 candles * 5 minutes = 1250 minutes = ~21 hours of data
                const startTime = endTime - (250 * 5 * 60 * 1000);
                
                const response = await fetch('https://api.hyperliquid.xyz/info', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        type: "candleSnapshot",
                        req: {
                            coin: "BTC",
                            interval: "5m",
                            startTime: startTime,
                            endTime: endTime
                        }
                    })
                });
                
                const data = await response.json();
                console.log('Historical data received:', data.length, 'candles');
                
                // Convert to Lightweight Charts format
                candleHistory = data.map(candle => ({
                    time: Math.floor(candle.t / 1000), // Convert to seconds
                    open: parseFloat(candle.o),
                    high: parseFloat(candle.h),
                    low: parseFloat(candle.l),
                    close: parseFloat(candle.c)
                })).sort((a, b) => a.time - b.time);
                
                console.log('Formatted historical data:', candleHistory.length, 'candles');
                
                // Update charts with historical data
                updateChartsWithHistoricalData();
                historicalDataLoaded = true;
                
                return true;
            } catch (error) {
                console.error('Error fetching historical data:', error);
                return false;
            }
        }
        
        // Update charts with historical data
        function updateChartsWithHistoricalData() {
            if (candleHistory.length === 0) return;
            
            // Update candlestick chart
            if (chartSeries.candlestick) {
                chartSeries.candlestick.setData(candleHistory);
            }
            
            // Update other charts with close prices
            const lineData = candleHistory.map(candle => ({
                time: candle.time,
                value: candle.close
            }));
            
            if (chartSeries.line) {
                chartSeries.line.setData(lineData);
            }
            
            if (chartSeries.area) {
                chartSeries.area.setData(lineData);
            }
            
            if (chartSeries.bar) {
                chartSeries.bar.setData(lineData);
            }
            
            console.log('Updated charts with historical data');
        }

        // Connect to Hyperliquid WebSocket
        async function connectWebSocket() {
            if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
                return;
            }
            
            // First fetch historical data
            const historyLoaded = await fetchHistoricalData();
            if (!historyLoaded) {
                console.error('Failed to load historical data');
                return;
            }
            
            ws = new WebSocket('wss://api.hyperliquid.xyz/ws');
            
            ws.onopen = function() {
                console.log('WebSocket connected to Hyperliquid');
                isConnected = true;
                updateWebSocketButton();
                
                // Subscribe to BTC perpetual 5m candlestick data
                const subscription = {
                    method: "subscribe",
                    subscription: {
                        type: "candle",
                        coin: "BTC",
                        interval: "5m"
                    }
                };
                
                ws.send(JSON.stringify(subscription));
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('WebSocket message received:', data);
                
                // Handle candle data
                if (data.channel === "candle" && data.data) {
                    handleCandleData(data.data);
                } else if (data.data && Array.isArray(data.data)) {
                    // Handle if data is directly in data field
                    handleCandleData(data.data);
                } else if (Array.isArray(data)) {
                    // Handle if data is directly an array
                    handleCandleData(data);
                }
            };
            
            ws.onclose = function() {
                console.log('WebSocket connection closed');
                isConnected = false;
                updateWebSocketButton();
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                isConnected = false;
                updateWebSocketButton();
            };
        }

        // Disconnect WebSocket
        function disconnectWebSocket() {
            if (ws) {
                ws.close();
                ws = null;
                isConnected = false;
                updateWebSocketButton();
                console.log('WebSocket disconnected');
            }
        }

        // Toggle WebSocket connection
        function toggleWebSocket() {
            if (isConnected) {
                disconnectWebSocket();
            } else {
                connectWebSocket();
            }
        }

        // Update WebSocket button text
        function updateWebSocketButton() {
            const button = document.querySelector('[data-label="websocket-toggle"]');
            if (button) {
                if (isConnected) {
                    button.textContent = 'ðŸ”Œ Disconnect WebSocket';
                    button.classList.add('active');
                } else {
                    button.textContent = 'ðŸ”Œ Connect WebSocket';
                    button.classList.remove('active');
                }
            }
        }

        // Handle incoming candle data
        function handleCandleData(candleData) {
            console.log('Handling live candle data:', candleData);
            
            // Handle single candle object
            if (typeof candleData === 'object' && candleData.t) {
                const formattedCandle = {
                    time: Math.floor(candleData.t / 1000), // Convert milliseconds to seconds
                    open: parseFloat(candleData.o),
                    high: parseFloat(candleData.h),
                    low: parseFloat(candleData.l),
                    close: parseFloat(candleData.c)
                };
                
                console.log('Formatted live candle:', formattedCandle);
                
                // Check for gaps between historical and live data
                if (historicalDataLoaded && candleHistory.length > 0) {
                    const lastHistoricalCandle = candleHistory[candleHistory.length - 1];
                    const timeDifference = formattedCandle.time - lastHistoricalCandle.time;
                    const expectedInterval = 5 * 60; // 5 minutes in seconds
                    
                    console.log('Time difference between last historical and live:', timeDifference, 'seconds');
                    console.log('Expected interval:', expectedInterval, 'seconds');
                    
                    // If there's a gap, bridge it
                    if (timeDifference > expectedInterval) {
                        console.log('Gap detected between historical and live data');
                        bridgeDataGap(lastHistoricalCandle, formattedCandle);
                    }
                    
                    // Check if this candle should update the last historical candle or add a new one
                    if (formattedCandle.time === lastHistoricalCandle.time) {
                        // Update existing candle
                        console.log('Updating existing candle in history');
                        candleHistory[candleHistory.length - 1] = formattedCandle;
                        updateChartsWithHistoricalData();
                    } else {
                        // Add new candle to history
                        console.log('Adding new candle to history');
                        candleHistory.push(formattedCandle);
                        
                        // Keep only last 250 candles
                        if (candleHistory.length > 250) {
                            candleHistory = candleHistory.slice(-250);
                        }
                        
                        updateChartsWithHistoricalData();
                    }
                } else {
                    // No historical data, just update with live data
                    console.log('No historical data, updating with live candle only');
                    if (chartSeries.candlestick) {
                        chartSeries.candlestick.update(formattedCandle);
                    }
                    
                    const linePoint = {
                        time: formattedCandle.time,
                        value: formattedCandle.close
                    };
                    
                    if (chartSeries.line) {
                        chartSeries.line.update(linePoint);
                    }
                    
                    if (chartSeries.area) {
                        chartSeries.area.update(linePoint);
                    }
                    
                    if (chartSeries.bar) {
                        chartSeries.bar.update(linePoint);
                    }
                }
                
                return;
            }
            
            console.error('Unexpected candle data format:', typeof candleData, candleData);
        }
        
        // Bridge gap between historical and live data
        function bridgeDataGap(lastHistoricalCandle, firstLiveCandle) {
            console.log('Bridging data gap from', lastHistoricalCandle.time, 'to', firstLiveCandle.time);
            
            const interval = 5 * 60; // 5 minutes in seconds
            const gapCandles = [];
            
            let currentTime = lastHistoricalCandle.time + interval;
            
            while (currentTime < firstLiveCandle.time) {
                // Create bridge candle using last historical close price
                const bridgeCandle = {
                    time: currentTime,
                    open: lastHistoricalCandle.close,
                    high: lastHistoricalCandle.close,
                    low: lastHistoricalCandle.close,
                    close: lastHistoricalCandle.close
                };
                
                console.log('Created bridge candle:', bridgeCandle);
                gapCandles.push(bridgeCandle);
                currentTime += interval;
            }
            
            // Add bridge candles to history
            candleHistory = candleHistory.concat(gapCandles);
            console.log('Added', gapCandles.length, 'bridge candles');
        }
        
        // Update all charts with current candle history
        function updateAllCharts() {
            if (candleHistory.length === 0) return;
            
            console.log('Updating charts with data:', candleHistory);
            console.log('Chart series available:', Object.keys(chartSeries));
            
            // Update candlestick chart
            if (chartSeries.candlestick) {
                console.log('Setting candlestick data:', candleHistory);
                chartSeries.candlestick.setData(candleHistory);
            } else {
                console.error('Candlestick series not found');
            }
            
            // Update line chart with close prices
            const lineData = candleHistory.map(candle => ({
                time: candle.time,
                value: candle.close
            }));
            
            if (chartSeries.line) {
                console.log('Setting line data:', lineData);
                chartSeries.line.setData(lineData);
            } else {
                console.error('Line series not found');
            }
            
            // Update area chart with close prices
            if (chartSeries.area) {
                console.log('Setting area data:', lineData);
                chartSeries.area.setData(lineData);
            } else {
                console.error('Area series not found');
            }
            
            // Update bar chart with close prices
            if (chartSeries.bar) {
                console.log('Setting bar data:', lineData);
                chartSeries.bar.setData(lineData);
            } else {
                console.error('Bar series not found');
            }
            
            console.log(`Updated charts with ${candleHistory.length} candles`);
            
            // Force chart resize to ensure visibility
            Object.values(charts).forEach(chart => {
                if (chart) {
                    chart.timeScale().fitContent();
                }
            });
        }

        // Show specific chart
        function showChart(chartType) {
            console.log('showChart called with:', chartType);
            
            // Hide all charts
            document.querySelectorAll('.chart-container').forEach(container => {
                console.log('Hiding container:', container.id);
                container.style.display = 'none';
            });
            
            // Remove active class from all menu items
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Show selected chart
            const targetChart = document.getElementById(chartType + '-chart');
            console.log('Showing chart container:', targetChart);
            targetChart.style.display = 'block';
            document.querySelector(`[data-label="${chartType}-menu"]`).classList.add('active');
            
            currentChart = chartType;
            localStorage.setItem('LWtest_currentChart', chartType);
            
            // Resize chart to fit container
            setTimeout(() => {
                console.log('Resizing chart:', chartType);
                if (charts[chartType]) {
                    console.log('Chart exists, calling resize');
                    charts[chartType].resize();
                    
                    // Check if data still exists after resize
                    console.log('Checking series after resize:', chartSeries[chartType]);
                    if (chartSeries[chartType]) {
                        console.log('Series still exists after resize');
                    } else {
                        console.error('Series lost after resize!');
                    }
                } else {
                    console.error('Chart not found for resize:', chartType);
                }
            }, 100);
        }

        // Reset chart zoom
        function resetChart(chartType) {
            if (charts[chartType]) {
                charts[chartType].timeScale().resetTimeScale();
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            Object.values(charts).forEach(chart => {
                chart.resize();
            });
        });

        // Load saved chart preference
        document.addEventListener('DOMContentLoaded', () => {
            currentChart = 'candlestick';
            
            console.log('DOM loaded, initializing charts');
            initCharts();
            console.log('Charts initialized, skipping showChart call');
            
            // Don't call showChart - leave the chart as initialized
        });
    </script>
</body>
</html>
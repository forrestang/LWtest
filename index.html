<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LWtest - Lightweight Charts Demo</title>
    <script src="https://unpkg.com/lightweight-charts@5.0.8/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .left-menu {
            width: 250px;
            background-color: #2c3e50;
            color: white;
            padding: 20px 0;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        .menu-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid #34495e;
            margin-bottom: 20px;
        }

        .menu-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: background-color 0.3s;
            border-left: 3px solid transparent;
        }

        .menu-item:hover {
            background-color: #34495e;
            border-left-color: #3498db;
        }

        .menu-item.active {
            background-color: #3498db;
            border-left-color: #2980b9;
        }

        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .chart-title {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 18px;
            font-weight: bold;
        }

        .chart {
            width: 100%;
            height: 400px;
        }

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn:hover {
            background-color: #2980b9;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="left-menu" data-label="main-navigation">
            <div class="menu-header">
                <h2>LWtest Charts</h2>
            </div>
            <div class="menu-item active" data-label="candlestick-menu" onclick="showChart('candlestick')">
                ðŸ“ˆ Candlestick Chart
            </div>
            <div class="menu-item" data-label="line-menu" onclick="showChart('line')">
                ðŸ“Š Line Chart
            </div>
            <div class="menu-item" data-label="bar-menu" onclick="showChart('bar')">
                ðŸ“‹ Bar Chart
            </div>
            <div class="menu-item" data-label="websocket-toggle" onclick="toggleWebSocket()">
                ðŸ”Œ Connect WebSocket
            </div>
            <div style="padding: 15px 20px; border-top: 1px solid #34495e;">
                <div style="color: #bdc3c7; font-size: 14px; margin-bottom: 10px;">Display Mode:</div>
                <label style="display: flex; align-items: center; margin-bottom: 15px; cursor: pointer;">
                    <input type="checkbox" id="percentage-checkbox" data-label="percentage-checkbox" onchange="togglePercentageMode()" style="margin-right: 8px;">
                    <span style="color: #f39c12;">ðŸ“Š Percentage</span>
                </label>
            </div>
            <div style="padding: 15px 20px; border-top: 1px solid #34495e;">
                <div style="color: #bdc3c7; font-size: 14px; margin-bottom: 10px;">Symbols:</div>
                <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                    <input type="checkbox" id="btc-checkbox" data-label="btc-checkbox" checked onchange="toggleSymbol('BTC')" style="margin-right: 8px;">
                    <span style="color: #e74c3c;">ðŸ”´ BTC</span>
                </label>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="eth-checkbox" data-label="eth-checkbox" onchange="toggleSymbol('ETH')" style="margin-right: 8px;">
                    <span style="color: #00bcd4;">ðŸ”µ ETH</span>
                </label>
            </div>
        </nav>

        <main class="main-content">
            <div id="main-chart" class="chart-container" data-label="main-container">
                <div class="chart-title" id="chart-title">Candlestick Chart</div>
                <div class="chart" data-label="chart-area"></div>
                <div class="controls">
                    <button class="btn" data-label="chart-reset" onclick="resetChart()">Reset Zoom</button>
                </div>
            </div>
        </main>
    </div>


    <script>
        const { createChart, ColorType, CandlestickSeries, LineSeries, BarSeries } = LightweightCharts;
        
        let charts = {};
        let chartSeries = new Map(); // Use Map for better series management
        let currentChart = 'candlestick';
        let ws = null;
        let isConnected = false;
        let candleHistory = {
            BTC: [],
            ETH: []
        };
        let historicalDataLoaded = {
            BTC: false,
            ETH: false
        };
        let activeSymbols = new Set(['BTC']); // Track which symbols are enabled
        let isPercentageMode = false; // Track percentage mode state
        
        // Scale state preservation for preventing autoscaling during chart type changes
        function captureScaleState() {
            if (!charts.main) return null;
            
            try {
                const timeScale = charts.main.timeScale();
                const priceScale = charts.main.priceScale('right');
                
                // Capture both visible range and logical range for precise positioning
                const visibleLogicalRange = timeScale.getVisibleLogicalRange();
                const visibleRange = timeScale.getVisibleRange();
                const priceRange = priceScale.getVisibleRange();
                
                return {
                    visibleLogicalRange,
                    visibleRange,
                    priceRange
                };
            } catch (error) {
                console.log('Could not capture scale state:', error);
                return null;
            }
        }
        
        function restoreScaleState(scaleState) {
            if (!charts.main || !scaleState) return;
            
            try {
                const timeScale = charts.main.timeScale();
                const priceScale = charts.main.priceScale('right');
                
                // Try to restore logical range first (preserves exact positioning and margins)
                if (scaleState.visibleLogicalRange) {
                    timeScale.setVisibleLogicalRange(scaleState.visibleLogicalRange);
                } else if (scaleState.visibleRange) {
                    // Fallback to visible range
                    timeScale.setVisibleRange(scaleState.visibleRange);
                }
                
                // Restore price range  
                if (scaleState.priceRange) {
                    priceScale.setVisibleRange(scaleState.priceRange);
                }
                
                console.log('Scale state restored with logical range preservation');
            } catch (error) {
                console.log('Could not restore scale state:', error);
                // Try fallback approach
                try {
                    if (scaleState.visibleRange) {
                        const timeScale = charts.main.timeScale();
                        timeScale.setVisibleRange(scaleState.visibleRange);
                    }
                } catch (fallbackError) {
                    console.log('Fallback scale restoration also failed:', fallbackError);
                }
            }
        }


        // Initialize single chart instance
        function initCharts() {
            // Create single chart instance
            const chartContainer = document.querySelector('[data-label="chart-area"]');
            const chart = createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: 400,
                layout: {
                    background: { type: ColorType.Solid, color: 'white' },
                    textColor: 'black',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                timeScale: {
                    borderColor: '#ccc',
                },
                rightPriceScale: {
                    borderColor: '#ccc',
                    autoScale: false,
                },
            });

            charts.main = chart;
            
            // Apply autoScale: false using applyOptions method
            charts.main.priceScale('right').applyOptions({
                autoScale: false
            });
            
            console.log('Single chart instance created');
            
            // Create initial series based on current chart type
            createChartSeries();
        }
        
        // Create or update chart series based on current chart type
        function createChartSeries() {
            if (!charts.main) return;
            
            // Capture current scale state before recreating series
            const scaleState = captureScaleState();
            
            // Clear existing series
            chartSeries.forEach((series) => {
                try {
                    if (series && charts.main) {
                        charts.main.removeSeries(series);
                    }
                } catch (error) {
                    console.error('Error removing series:', error);
                }
            });
            chartSeries.clear();
            
            // Create series for ALL symbols (BTC and ETH) with transparent colors for inactive ones
            const allSymbols = ['BTC', 'ETH'];
            
            for (const symbol of allSymbols) {
                let series;
                const isActive = activeSymbols.has(symbol);
                const transparentColor = 'rgba(0,0,0,0)';
                
                if (currentChart === 'candlestick') {
                    series = charts.main.addSeries(CandlestickSeries, {
                        upColor: isActive ? (symbol === 'BTC' ? '#e74c3c' : '#00bcd4') : transparentColor,
                        downColor: isActive ? (symbol === 'BTC' ? '#c0392b' : '#0097a7') : transparentColor,
                        borderVisible: false,
                        wickUpColor: isActive ? (symbol === 'BTC' ? '#e74c3c' : '#00bcd4') : transparentColor,
                        wickDownColor: isActive ? (symbol === 'BTC' ? '#c0392b' : '#0097a7') : transparentColor,
                    });
                } else if (currentChart === 'line') {
                    series = charts.main.addSeries(LineSeries, {
                        color: isActive ? (symbol === 'BTC' ? '#e74c3c' : '#00bcd4') : transparentColor,
                        lineWidth: 2,
                    });
                } else if (currentChart === 'bar') {
                    series = charts.main.addSeries(BarSeries, {
                        upColor: isActive ? (symbol === 'BTC' ? '#e74c3c' : '#00bcd4') : transparentColor,
                        downColor: isActive ? (symbol === 'BTC' ? '#c0392b' : '#0097a7') : transparentColor,
                    });
                }
                
                if (series) {
                    chartSeries.set(symbol, series);
                    console.log(`Created ${currentChart} series for ${symbol} (active: ${isActive})`);
                }
            }
            
            // Reapply autoScale: false after series creation
            charts.main.priceScale('right').applyOptions({
                autoScale: false
            });
            
            // Update with existing data
            updateChartData();
            
            // Restore scale state after data is updated
            setTimeout(() => {
                restoreScaleState(scaleState);
            }, 50);
        }
        
        // Update chart data for all active series
        function updateChartData() {
            if (!charts.main || chartSeries.size === 0) return;
            
            chartSeries.forEach((series, symbol) => {
                if (candleHistory[symbol] && candleHistory[symbol].length > 0) {
                    let processedData = candleHistory[symbol];
                    
                    // Apply percentage transformation if enabled
                    if (isPercentageMode) {
                        processedData = convertToPercentage(candleHistory[symbol]);
                    }
                    
                    // Transform to line format if chart type is line
                    if (currentChart === 'line') {
                        processedData = processedData.map(candle => ({
                            time: candle.time,
                            value: candle.close
                        }));
                    }
                    
                    // Validate data
                    let validData;
                    if (currentChart === 'candlestick' || currentChart === 'bar') {
                        validData = processedData.filter(candle => 
                            candle && 
                            typeof candle.open === 'number' && !isNaN(candle.open) &&
                            typeof candle.high === 'number' && !isNaN(candle.high) &&
                            typeof candle.low === 'number' && !isNaN(candle.low) &&
                            typeof candle.close === 'number' && !isNaN(candle.close)
                        );
                    } else {
                        validData = processedData.filter(point => point && typeof point.value === 'number' && !isNaN(point.value));
                    }
                    
                    console.log(`Setting ${symbol} data for ${currentChart}:`, validData.length, 'points');
                    series.setData(validData);
                }
            });
        }
        
        // Toggle percentage mode
        function togglePercentageMode() {
            const checkbox = document.getElementById('percentage-checkbox');
            isPercentageMode = checkbox.checked;
            localStorage.setItem('LWtest_percentageMode', isPercentageMode);
            
            // Update chart data with current mode
            updateChartData();
            
            // When switching percentage modes, we need to let the price scale auto-fit
            // to the new data range, then reapply autoScale: false
            setTimeout(() => {
                if (charts.main) {
                    // Temporarily allow auto-scaling to fit new data range
                    charts.main.priceScale('right').applyOptions({ autoScale: true });
                    
                    // Then disable it again after the scale adjusts
                    setTimeout(() => {
                        charts.main.priceScale('right').applyOptions({ autoScale: false });
                    }, 100);
                }
            }, 50);
        }
        
        // Convert candle data to percentage change from first candle
        function convertToPercentage(candleData) {
            if (!candleData || candleData.length === 0) return candleData;
            
            const firstCandle = candleData[0];
            const firstPrice = firstCandle.close;
            
            return candleData.map(candle => ({
                time: candle.time,
                open: ((candle.open - firstPrice) / firstPrice) * 100,
                high: ((candle.high - firstPrice) / firstPrice) * 100,
                low: ((candle.low - firstPrice) / firstPrice) * 100,
                close: ((candle.close - firstPrice) / firstPrice) * 100
            }));
        }
        
        // Convert line data to percentage change from first value
        function convertLineToPercentage(lineData) {
            if (!lineData || lineData.length === 0) return lineData;
            
            const firstValue = lineData[0].value;
            
            return lineData.map(point => ({
                time: point.time,
                value: ((point.value - firstValue) / firstValue) * 100
            }));
        }

        // Load sample data for initial chart display  
        function loadInitialSampleData() {
            console.log('Loading sample data for initial display');
            const now = Math.floor(Date.now() / 1000);
            
            // Create sample data for both BTC and ETH
            const symbols = [
                { name: 'BTC', basePrice: 100000 },
                { name: 'ETH', basePrice: 3000 }
            ];
            
            symbols.forEach(({ name, basePrice }) => {
                candleHistory[name] = [];
                
                for (let i = 0; i < 100; i++) {
                    const time = now - (100 - i) * 300; // 5 minute intervals, going back ~8 hours
                    const priceVariation = basePrice * 0.02; // 2% price variation
                    const centerPrice = basePrice + (Math.sin(i * 0.1) * priceVariation);
                    
                    const open = centerPrice + (Math.random() - 0.5) * priceVariation * 0.5;
                    const close = centerPrice + (Math.random() - 0.5) * priceVariation * 0.5;
                    const high = Math.max(open, close) + Math.random() * priceVariation * 0.3;
                    const low = Math.min(open, close) - Math.random() * priceVariation * 0.3;
                    
                    candleHistory[name].push({
                        time: time,
                        open: parseFloat(open.toFixed(2)),
                        high: parseFloat(high.toFixed(2)),
                        low: parseFloat(low.toFixed(2)),
                        close: parseFloat(close.toFixed(2))
                    });
                }
                
                console.log(`Created sample ${name} data:`, candleHistory[name].length, 'candles');
                historicalDataLoaded[name] = true;
            });
            
            // Update chart with sample data
            updateChartData();
            
            // Fit content and ensure price scale is visible
            if (charts.main) {
                setTimeout(() => {
                    charts.main.timeScale().fitContent();
                    // Reapply autoScale: false after fitContent
                    charts.main.priceScale('right').applyOptions({ autoScale: false });
                }, 100);
            }
        }
        
        // Toggle symbol visibility
        function toggleSymbol(symbol) {
            const checkbox = document.getElementById(`${symbol.toLowerCase()}-checkbox`);
            
            if (checkbox.checked) {
                activeSymbols.add(symbol);
                console.log(`${symbol} enabled`);
            } else {
                activeSymbols.delete(symbol);
                console.log(`${symbol} disabled`);
            }
            
            // Update series colors instead of recreating
            if (chartSeries.has(symbol)) {
                const series = chartSeries.get(symbol);
                const isActive = activeSymbols.has(symbol);
                const transparentColor = 'rgba(0,0,0,0)';
                
                if (currentChart === 'candlestick') {
                    series.applyOptions({
                        upColor: isActive ? (symbol === 'BTC' ? '#e74c3c' : '#00bcd4') : transparentColor,
                        downColor: isActive ? (symbol === 'BTC' ? '#c0392b' : '#0097a7') : transparentColor,
                        wickUpColor: isActive ? (symbol === 'BTC' ? '#e74c3c' : '#00bcd4') : transparentColor,
                        wickDownColor: isActive ? (symbol === 'BTC' ? '#c0392b' : '#0097a7') : transparentColor,
                    });
                } else if (currentChart === 'line') {
                    series.applyOptions({
                        color: isActive ? (symbol === 'BTC' ? '#e74c3c' : '#00bcd4') : transparentColor,
                    });
                } else if (currentChart === 'bar') {
                    series.applyOptions({
                        upColor: isActive ? (symbol === 'BTC' ? '#e74c3c' : '#00bcd4') : transparentColor,
                        downColor: isActive ? (symbol === 'BTC' ? '#c0392b' : '#0097a7') : transparentColor,
                    });
                }
                
                console.log(`${symbol} series colors updated (active: ${isActive})`);
            } else {
                // If series doesn't exist yet, recreate all series
                console.log(`${symbol} series not found, recreating all series`);
                createChartSeries();
            }
        }
        


        // Fetch historical candle data from Hyperliquid API
        async function fetchHistoricalData() {
            const promises = [];
            
            // Fetch data for ALL symbols (both BTC and ETH) so they can be toggled
            const allSymbols = ['BTC', 'ETH'];
            for (const symbol of allSymbols) {
                promises.push(fetchHistoricalDataForSymbol(symbol));
            }
            
            const results = await Promise.all(promises);
            const allLoaded = results.every(result => result === true);
            
            // Force series recreation after initial data load to ensure proper display
            if (allLoaded) {
                console.log('All historical data loaded, recreating series to ensure proper display');
                createChartSeries();
            }
            
            return allLoaded;
        }
        
        // Fetch historical data for a specific symbol
        async function fetchHistoricalDataForSymbol(symbol) {
            try {
                console.log(`Fetching historical ${symbol} 5m candle data...`);
                
                const endTime = Date.now();
                // Get 250 candles * 5 minutes = 1250 minutes = ~21 hours of data
                const startTime = endTime - (250 * 5 * 60 * 1000);
                
                const response = await fetch('https://api.hyperliquid.xyz/info', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        type: "candleSnapshot",
                        req: {
                            coin: symbol,
                            interval: "5m",
                            startTime: startTime,
                            endTime: endTime
                        }
                    })
                });
                
                const data = await response.json();
                console.log(`${symbol} historical data received:`, data.length, 'candles');
                
                
                // Convert to Lightweight Charts format
                candleHistory[symbol] = data.map(candle => ({
                    time: Math.floor(candle.t / 1000), // Convert to seconds
                    open: parseFloat(candle.o),
                    high: parseFloat(candle.h),
                    low: parseFloat(candle.l),
                    close: parseFloat(candle.c)
                })).sort((a, b) => a.time - b.time);
                
                console.log(`Formatted ${symbol} historical data:`, candleHistory[symbol].length, 'candles');
                
                // Update charts with historical data for this symbol
                updateChartData();
                
                // Fit content only on initial data load
                if (charts.main) {
                    charts.main.timeScale().fitContent();
                    // Re-apply autoScale: false after fitting content
                    charts.main.priceScale('right').applyOptions({ autoScale: false });
                }
                
                historicalDataLoaded[symbol] = true;
                
                return true;
            } catch (error) {
                console.error(`Error fetching ${symbol} historical data:`, error);
                return false;
            }
        }
        

        // Connect to Hyperliquid WebSocket
        async function connectWebSocket() {
            if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
                return;
            }
            
            // First fetch historical data
            const historyLoaded = await fetchHistoricalData();
            if (!historyLoaded) {
                console.error('Failed to load historical data');
                return;
            }
            
            ws = new WebSocket('wss://api.hyperliquid.xyz/ws');
            
            ws.onopen = function() {
                console.log('WebSocket connected to Hyperliquid');
                isConnected = true;
                updateWebSocketButton();
                
                // Subscribe to candle data for all active symbols
                for (const symbol of activeSymbols) {
                    const subscription = {
                        method: "subscribe",
                        subscription: {
                            type: "candle",
                            coin: symbol,
                            interval: "5m"
                        }
                    };
                    
                    console.log(`Subscribing to ${symbol} candle data`);
                    ws.send(JSON.stringify(subscription));
                }
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('WebSocket message received:', data);
                
                // Handle candle data
                if (data.channel === "candle" && data.data) {
                    handleCandleData(data.data);
                } else if (data.data && Array.isArray(data.data)) {
                    // Handle if data is directly in data field
                    handleCandleData(data.data);
                } else if (Array.isArray(data)) {
                    // Handle if data is directly an array
                    handleCandleData(data);
                }
            };
            
            ws.onclose = function() {
                console.log('WebSocket connection closed');
                isConnected = false;
                updateWebSocketButton();
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                isConnected = false;
                updateWebSocketButton();
            };
        }

        // Disconnect WebSocket
        function disconnectWebSocket() {
            if (ws) {
                ws.close();
                ws = null;
                isConnected = false;
                updateWebSocketButton();
                console.log('WebSocket disconnected');
            }
        }

        // Toggle WebSocket connection
        function toggleWebSocket() {
            if (isConnected) {
                disconnectWebSocket();
            } else {
                connectWebSocket();
            }
        }

        // Update WebSocket button text
        function updateWebSocketButton() {
            const button = document.querySelector('[data-label="websocket-toggle"]');
            if (button) {
                if (isConnected) {
                    button.textContent = 'ðŸ”Œ Disconnect WebSocket';
                    button.classList.add('active');
                } else {
                    button.textContent = 'ðŸ”Œ Connect WebSocket';
                    button.classList.remove('active');
                }
            }
        }

        // Handle incoming candle data
        function handleCandleData(candleData) {
            console.log('Handling live candle data:', candleData);
            
            // Handle single candle object
            if (typeof candleData === 'object' && candleData.t && candleData.s) {
                const symbol = candleData.s; // Get symbol from candle data
                
                // Only process if this symbol is active
                if (!activeSymbols.has(symbol)) {
                    console.log(`Ignoring candle for inactive symbol: ${symbol}`);
                    return;
                }
                
                const formattedCandle = {
                    time: Math.floor(candleData.t / 1000), // Convert milliseconds to seconds
                    open: parseFloat(candleData.o),
                    high: parseFloat(candleData.h),
                    low: parseFloat(candleData.l),
                    close: parseFloat(candleData.c)
                };
                
                console.log(`Formatted live ${symbol} candle:`, formattedCandle);
                
                // Check for gaps between historical and live data
                if (historicalDataLoaded[symbol] && candleHistory[symbol] && candleHistory[symbol].length > 0) {
                    const lastHistoricalCandle = candleHistory[symbol][candleHistory[symbol].length - 1];
                    const timeDifference = formattedCandle.time - lastHistoricalCandle.time;
                    const expectedInterval = 5 * 60; // 5 minutes in seconds
                    
                    console.log(`${symbol} time difference between last historical and live:`, timeDifference, 'seconds');
                    
                    // If there's a gap, bridge it
                    if (timeDifference > expectedInterval) {
                        console.log(`Gap detected between historical and live data for ${symbol}`);
                        bridgeDataGap(symbol, lastHistoricalCandle, formattedCandle);
                    }
                    
                    // Check if this candle should update the last historical candle or add a new one
                    if (formattedCandle.time === lastHistoricalCandle.time) {
                        // Update existing candle
                        console.log(`Updating existing ${symbol} candle in history`);
                        candleHistory[symbol][candleHistory[symbol].length - 1] = formattedCandle;
                        updateChartData();
                    } else {
                        // Add new candle to history
                        console.log(`Adding new ${symbol} candle to history`);
                        candleHistory[symbol].push(formattedCandle);
                        
                        // Keep only last 250 candles
                        if (candleHistory[symbol].length > 250) {
                            candleHistory[symbol] = candleHistory[symbol].slice(-250);
                        }
                        
                        updateChartData();
                    }
                } else {
                    // No historical data, just update with live data
                    console.log(`No historical data for ${symbol}, updating with live candle only`);
                    
                    let candleToUpdate = formattedCandle;
                    let linePoint = {
                        time: formattedCandle.time,
                        value: formattedCandle.close
                    };
                    
                    // Apply percentage transformation if enabled and we have data
                    if (isPercentageMode && candleHistory[symbol] && candleHistory[symbol].length > 0) {
                        const firstPrice = candleHistory[symbol][0].close;
                        candleToUpdate = {
                            time: formattedCandle.time,
                            open: ((formattedCandle.open - firstPrice) / firstPrice) * 100,
                            high: ((formattedCandle.high - firstPrice) / firstPrice) * 100,
                            low: ((formattedCandle.low - firstPrice) / firstPrice) * 100,
                            close: ((formattedCandle.close - firstPrice) / firstPrice) * 100
                        };
                        linePoint.value = candleToUpdate.close;
                    }
                    
                    if (chartSeries[symbol]) {
                        chartSeries[symbol].update(candleToUpdate);
                    }
                    
                    if (chartSeries[symbol + 'Line']) {
                        chartSeries[symbol + 'Line'].update(linePoint);
                    }
                    
                    if (chartSeries[symbol + 'Bar']) {
                        chartSeries[symbol + 'Bar'].update(candleToUpdate);
                    }
                }
                
                return;
            }
            
            console.error('Unexpected candle data format:', typeof candleData, candleData);
        }
        
        // Bridge gap between historical and live data
        function bridgeDataGap(symbol, lastHistoricalCandle, firstLiveCandle) {
            console.log(`Bridging ${symbol} data gap from`, lastHistoricalCandle.time, 'to', firstLiveCandle.time);
            
            const interval = 5 * 60; // 5 minutes in seconds
            const gapCandles = [];
            
            let currentTime = lastHistoricalCandle.time + interval;
            
            while (currentTime < firstLiveCandle.time) {
                // Create bridge candle using last historical close price
                const bridgeCandle = {
                    time: currentTime,
                    open: lastHistoricalCandle.close,
                    high: lastHistoricalCandle.close,
                    low: lastHistoricalCandle.close,
                    close: lastHistoricalCandle.close
                };
                
                console.log(`Created ${symbol} bridge candle:`, bridgeCandle);
                gapCandles.push(bridgeCandle);
                currentTime += interval;
            }
            
            // Add bridge candles to history
            candleHistory[symbol] = candleHistory[symbol].concat(gapCandles);
            console.log(`Added ${gapCandles.length} bridge candles for ${symbol}`);
        }
        
        // Update all charts with current candle history
        function updateAllCharts() {
            if (candleHistory.length === 0) return;
            
            console.log('Updating charts with data:', candleHistory);
            console.log('Chart series available:', Object.keys(chartSeries));
            
            // Update candlestick chart
            if (chartSeries.candlestick) {
                console.log('Setting candlestick data:', candleHistory);
                chartSeries.candlestick.setData(candleHistory);
            } else {
                console.error('Candlestick series not found');
            }
            
            // Update line chart with close prices
            const lineData = candleHistory.map(candle => ({
                time: candle.time,
                value: candle.close
            }));
            
            if (chartSeries.line) {
                console.log('Setting line data:', lineData);
                chartSeries.line.setData(lineData);
            } else {
                console.error('Line series not found');
            }
            
            
            // Update bar chart with close prices
            if (chartSeries.bar) {
                console.log('Setting bar data:', lineData);
                chartSeries.bar.setData(lineData);
            } else {
                console.error('Bar series not found');
            }
            
            console.log(`Updated charts with ${candleHistory.length} candles`);
        }


        // Show specific chart type (now changes series instead of charts)
        function showChart(chartType) {
            console.log('Switching to chart type:', chartType);
            
            // Remove active class from all menu items
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Add active class to selected menu item
            document.querySelector(`[data-label="${chartType}-menu"]`).classList.add('active');
            
            // Update chart title
            const titles = {
                'candlestick': 'Candlestick Chart',
                'line': 'Line Chart',
                'bar': 'Bar Chart'
            };
            document.getElementById('chart-title').textContent = titles[chartType] || 'Chart';
            
            // Update current chart type and save preference
            currentChart = chartType;
            localStorage.setItem('LWtest_currentChart', chartType);
            
            // Recreate series for new chart type
            createChartSeries();
        }

        // Reset chart zoom
        function resetChart() {
            if (charts.main) {
                charts.main.timeScale().fitContent();
                // Reapply autoScale: false after fitContent
                charts.main.priceScale('right').applyOptions({ autoScale: false });
                console.log('Chart zoom reset');
            }
        }


        // Handle window resize
        window.addEventListener('resize', () => {
            if (charts.main) {
                charts.main.resize();
            }
        });

        // Load saved chart preference
        document.addEventListener('DOMContentLoaded', () => {
            currentChart = 'candlestick';
            
            // Load saved percentage mode preference
            const savedPercentageMode = localStorage.getItem('LWtest_percentageMode');
            if (savedPercentageMode === 'true') {
                isPercentageMode = true;
                document.getElementById('percentage-checkbox').checked = true;
            }
            
            console.log('DOM loaded, initializing charts');
            initCharts();
            
            // Load sample data for initial display
            loadInitialSampleData();
            
            console.log('Charts initialized with sample data. Click "Connect WebSocket" to load real data.');
        });
    </script>
</body>
</html>